\chapter{Implementation}\label{sec:implementation}

This section goes over the solutions and implementation that were selected over the course of the semester project. \\

To ensure clarity, this part will be keeping with the three-module  structure established in the previous chapter. 

\section{The Choreographer Application - User Experience}

\begin{figure}[ht]
   \centering
   \includegraphics[width=0.75\textwidth]{img/ChoreographerGUI.png}
   \caption{The CUBLI Choreographer Graphical User Interface.}
   \label{img:ChoreographerGUI}
\end{figure}

In the end the choreographer application is quite close to the initial concept. Whereas one could have expected it to evolve differently, the first approach has remained a valid implementation during the project and thus the concept has not deviated much from the outset.\\

One notable addition is the creation of a debugging panel, to the right of the main window, which can also be completely deactivated and hidden. When it is visible however, it provides access to all the communications, and to manually send out messages from the computer, or to simulate incoming messages from cubes.\\

\begin{figure}[ht]
   \centering
   \includegraphics[width=0.75\textwidth]{img/DebugPanel.png}
   \caption{The debugging \& information panel.}
   \label{img:DebugPanel}
\end{figure}

\subsection{Language}

C++ was the obvious choice for a language for three reasons: i) it allowed to reuse code structure from the C source with few modifications ii) the communication protocol could be compiled on the two different machines from the same C file, thus greatly reducing the chances of bugs appearing due to unvoluntary divergences in the protocol source code iii) On the first targeted machine, it had readily available libraries for all the necessary peripherals and UI elements, as well as useful object-oriented features. 
The libraries in question were taken from the QT development kit, a decision which was not obvious as the advantages of QT over Visual Studio appear marginal. \\

Just as the final application, in debugging mode, has two main panels - one concerning the user interaction, specifically the creation of timelines and control of the choreography evolution; one displaying communications through the serial port and state machine information - the development process was centered around two features : i) serial port communication and ii) timeline creation, transfer, and execution. 

\subsection{App Components}

Here we clarify the contents of various parts of the choreographer app source, as available in the Github repository. For each part, a general explanation is given, and if any are relevant, is followed by more technical details.

\subsubsection{Main Window}

First and foremost, this class displays and sets up the main viewport. It defines the action for all the buttons, and provides functions for updating text fields such as the app information.

As such it is mostly QT-specific code, with several functions handling the app behavior when connecting or syncing with cubes.

\subsubsection{Serial Manager}

Serial port communication was the first implemented functionality of the app, relatively easy to write thanks to the already well-built QT serial port libraries. In detail, successful sending entails: 

\begin{itemize}
\item setting the port name ( Later, a panel for setting those options easily, which among other things contains a drop down list enumerating the available port names was added ) 
\item setting the serial parameters, such as baud rate, hardware flow control and so on to the same values as inside cubli ( Baud rate of 115200, ) 
\item open the port. This is straightforward through a simple function call 
\item send bytes through the port. A function call is all that is needed here as well. 
\end{itemize}

Receiving is handled in an interrupt, which hands over control to a function written for that purpose.\\

Among other things this function displays all the received bytes in a serial stream display panel. In addition, any bytes sent by the Application over serial are also displayed in the same serial stream display panel with a line prefix of '>>' \\

The class named Serial Manager was created in order to handle those actions. 

\subsubsection{Timeline}

Created and displayed when each cube connects to the application, a white rectangular canvas on which the user can place, modify or remove color coded squares is meant to represent the chorography - the horizontal axis representing time, - and, as such, is called a Timeline. Each square, called a Primitive, represents a specific action of cubli, and thus, one or several Timelines, each containing a sequence of primitives, together represent a choreography. \\

\begin{figure}[ht]
   \centering
   \includegraphics[width=0.75\textwidth]{img/TimelinesPanel.png}
   \caption{The Timeline Editor panel.}
   \label{img:TimelinesPanel}
\end{figure}

For this purpose, within this projet the timeline canvas, or "Graphics Scene" in QT nomenclature, was programmed to respond to user interactions in the following ways: 
\begin{itemize}
\item Clicking on empty space creates a new primitive at that position 
\item Clicking a primitive modifies it, cycling through the available types one at a time 
\item Double clicks are no different from two simple clicks 
\item Left click-and-dragging a primitive moves it based on mouse position 
\item Right clicking a primitive erases it 
\item Right click-and-dragging erases all primitives under the cursors path 
\item Left click and dragging on empty space has no effect 
\end{itemize}

\subsubsection{Timeline - Technical Addendum}

QT allows the interception of mouse events inside the Timeline area through several functions, of which \texttt{MousePressEvent(), MouseMoveEvent(), MouseReleaseEvent(),} and \texttt{MouseDoubleClickEvent()} are used here. Each one of these functions is executed upon the appropriate event, \texttt{MousePressEvent()} in particular gets triggered by both left and right mouse clicks.  \texttt{MouseDoubleClickEvent()} replaces \texttt{MousePressEvent()} when the relevant click is second in a series.

Programmatically this behavior was encoded as follows: 

\begin{itemize}
\item[] \texttt{MousePressEvent()}: When a mouse button is pressed within the timeline bounds, the application checks whether a primitive is present under the cursor. In the case that the right mouse button was pressed, the primitive under the cursor is immediately deleted. Otherwise, the primitive under the cursor, if any, is simply marked ( "selected" ) for later. No further action is undertaken until another mouse event occurs. 
\item[]  \texttt{MouseMoveEvent()}: If a primitive is currently selected, it follows the position of the cursor, as far as collisions allow it.
\item[]  \texttt{MouseReleaseEvent()}: If a primitive is currently selected and no mouse movement was made, it is transformed into the next primitive type. If a primitive is currently selected and mouse movement was made, its type remains unchanged. If no primitive was selected, a new one is created. The primitive information panel is updated to reflect the latest selected or created primitive, and any selected primitive is unselected.
\item[]  \texttt{MouseDoubleClickEvent()}: In order to stay consistent with single click behavior, this function does exactly what a \texttt{MousePressEvent()} does.
\end{itemize}


\subsubsection{Primitive}

The primitive class is an extension of simple rectangle objects in the timeline, adding extra properties such as type, and automatically assigning styles, width, or positions, thus making them simpler to display and move around. These extended rectangle objects are meant to visually represent the action primitives of a cube in the choreography.\\

This class provides methods for easily accessing certain properties, modifying, or moving the primitives around, for example without running into each other.

\subsubsection{ComStateManager}

 The ComStateManager class is the part of the application which handles communication responses, i.e. \textit{what to send and when}.\\
 
Any message sent to the cube from the app means a call to this class. It is also where cube statuses are stored, which allow it and other parts of the application to take into account whether particular cubes are connected or not, syncing or not, and so on.\\

Which message must be sent is necessarily determined in this class' logic.
It accomplishes this through a state machine, that has a corresponding response for every incoming message or application call.\\

The protocols described in the next section are mostly encoded in here ( messages which are sent several times in a row originate from \texttt{mainwindow.cpp} code )

\subsubsection{SettingsDialog}

SettingsDialog is responsible for putting together the settings dialog which appears when the serial port settings are to be modified, and storing their values.

\subsubsection{Main.cpp}

Main runs the mainwindow code, launching the app, and any necessary QT routines.

\section{Communications}

The source for the message protocol fits inside one cpp file and accompanying header. It mainly creates or deconstructs strings or characters, in order to transmit and receive messages which satisfy the required specifications.\\

Of course, the concept of communication protocol as a whole pertains to more than uniquely this message-transmission code. It also englobes the determination of how the machines ought to behave when contacting each other, which in practice is encoded all over their code ( see communication state machines, MainWindow, etc ). However for the sake of consistency the particulars of these protocols are discussed here.\\

One of the difficulties during this project was the unreliability of the UART behavior in the cubli microcontroller. Thankfully the communication protocol was designed to be quite robust from the get-go, which seemed at the time like a potentially unnecessary amount of safety, though it proved essential.

\begin{figure}[ht]
   \centering
   \includegraphics[width=0.75\textwidth]{img/USART.png}
   \caption{USART Block diagram as shown in \cite{stm32manual}.}
   \label{img:USART}
\end{figure}

The inability to work with the assumption that 'the majority of messages would be able get through successfully' also meant that communication protocols were not simply a formality, and had to be designed with contingencies in mind. This made this module an interesting, though larger than anticipated, part of the project.

\subsection{com\_protocol}

Principally, this code transforms a message's code, additional content, and metadata into a normalized string of characters which can be sent one byte at a time over UART. And vice-versa.\\

It is here that the structure of a message is defined, and this code is valid on both Cublis and the choreography application.\\

[Message deconstruction] \\


\subsubsection{Header}

The header, com\_protocol.h contains enumerations for all the message codes, communications states, and a few other which are shared between cubli and computer, as well as some macro expansions which concern communication settings.\\

[Message code table]\\

It also contains two compile flags:\\

\begin{itemize}
\item[] COM\_VERBOSE

	if this flag is defined, messages also contain a human-readable appendix expliciting the relevant message code, and extra content.\\

\item[] COM\_DEBUG

	if this flag is defined, extra information pertaining to failure when decrypting messages is displayed as plain text. This is for example useful when messages are not getting decrypted though they are transmitted correctly.
    
\end{itemize}

\subsection{Information Reception \& Decryption}

The way Cublis and the choreographer application handle UART information is similar, although there are specific details that differ.\\

The step-by-step process of reception and decryption in both device types is as follows:\\

\begin{itemize}
\item At the lowest level, and on every device, all bytes emitted over UART are immediately captured and stored into a buffer - whether they are part of a message or not. The only exception, of course, are the bytes which fail to transmit for one reason or other.

\begin{description}
\item[In Cubli,] the buffer in question is a ring buffer named \textit{rx\_buf}. The interrupt routine \textit{USART1\_IRQHandler()} checks whether a byte has been stored in the UART register. If it has, it places the byte into \textit{rx\_buf} and empties the UART data register. Over time, the buffer fills up with sequences of bytes, and stops storing them when full. Since these interrupts are designed to be as light as possible, the actual emptying, and reading of the buffer has to be done somewhere else. In this case, the ComManagement task is responsible for that among other things, and does so in a periodic manner.
\item[In the Choreographer,] similar behavior is implemented in appropriate libraries. At this point, the aspect which differs from the cubli implementation is that these libraries are configured to immediately handle data after a burst of bytes is received - i.e. a call is made to the function \textit{readData()} after every group of bytes which are sent in quick succession. \textit{readData()} contains the next step in handling and decryption of the information.
As such, cubli performs the next step periodically, while the choreographer app does so in a responsive manner.
\end{description}

\item Next, the data present in the low-level buffers described above are appended to a second, higher-level buffer, which is accessed less often. The contents of this second buffer are passed to the \textit{decrypt\_message()} function in com\_protocol.c. If a message is present in these contents, it is disassembled, and verified. If a message is not intended to have the current device as a recipient, it is discarded. If its length or hash is invalid, it is also discarded.

\begin{description}
\item[In Cubli,] this step is done inside the ComManagement task. Particularities are: the buffer is erased and overwritten on every loop of the task, instead of having the new data appended to it. This is due to the fact that testing of the append-data method yielded worst results, against expectations. \textit{ It is hypothesised that the period of the ComManagement task being larger than the time it takes for the choreographer to emit an entire sequence of bytes composing a message, and that length of time being extremely small, chances of messages being separated is very low. Low enough that the append-data method's advantage, that is, reconstitution of separated messages, is not significant enough to compensate the performance loss due to increase in task complexity.}
\item[In the Choreographer,] data is appended on the high-level buffer, thus separated messages are reconstituted. This was shown to have a significant positive impact, as the likelihood of messages being separated upon reception by the choreographer app is higher - likely due to the event-based nature of the choreographer UART data handling.
An interesting point is the fact that as soon as the first message present in the buffer is read ( more precisely, if \textit{decrypt\_message()} returns a non-zero value ), the entire buffer is cleared and any messages already present in the remaining bytes is thus thrown away. This was done to keep up with the high communication frequency that can arise - in the case where messages are emitted too fast, if the app were to treat every single one it would progressively lag behind ( this has been tested, and is effectively the case ). 
\end{description}

\item At this point, the devices can handle the decrypted message, thanks to their appropriate communication state machines. 

\begin{description}
\item[In Cubli's case,] the absence of any data, or the presence of data which does not contain a valid message are also handled. This is useful as a consequence of the periodic aspect of the ComManagement task. 
\item[In the Choreographer,] button or interface events can also be passed to the state machine, in order to have communication responses to those inputs.
\end{description}

\end{itemize}

\subsection{Protocols}

The protocols which determine the communication behavior of every device are strongly dependent on the situation, more precisely the state in which a device is. \\

This is due to the significant transmission failure rate experienced during the project. 

Such a transmission rate means that not every desired aspect of a program can be attained, and the type of protocol used determines which aspect is impacted most when transmissions fail. Each situation had different critical aspects which needed to be prioritized, thus the protocols had to be adapted accordingly.\\

In this report, a \textit{communication protocol} refers to the rules of communication between devices, which state what the standard procedure is in a back-and-forth exchange of information, and all alternate procedures if at any point a message fails to transmit.\\

Such a standard procedure can for example be explicited as follows:
\begin{itemize}
\item[] \textbf{A to B:} "start of protocol"
\item[] \textbf{B to A:} "confirmation"
\item[] \textbf{A to B:} "end of protocol"
\end{itemize}

when all involved parties have received their intended messages, the protocol is considered as having completed successfully.

Alternate procedures describe the prescribed response when a message from the standard procedure is not delivered as intended.

\subsubsection{In General}

Some proprieties of the communication protocols created for this project are generally true.

The last message of any protocol procedure is a sensitive one, as there is nothing in the procedure itself that allows the emitting party to be aware of whether the receiving party has successfully collected it ( if an extra confirmation is added for this purpose, this confirmation becomes the last message of the protocol, and the same issue applies once again. And so on. ). 
It is therefore to be expected that one device, having not received the ultimate message of the protocol procedure, is still expecting it, while the other device, having sent it, considers the protocol procedure completed.
In that case, or if for any other reason one device remains stuck in procedure while the other one does not - e.g. if one of the two is reset unexpectedly - it is necessary to implement general or specific protocol-aborting procedures.\\

For example the use of a timeout allows such a stuck-device to exit the procedure by itself.
Another solution, used to good effect in this project, is to allow devices to respond to these tell-tale "second-to-last messages" with the correct protocol terminating message, without themselves being in the same state.\\

An illustration of this, for clarification purposes; take the example protocol illustrated previously:

\begin{itemize}
\item[] \textbf{A to B:} "start of protocol"
\item[] \textbf{B to A:} "confirmation"
\item[] \textbf{A to B:} "end of protocol"
\end{itemize}

\subsubsection{When Connecting}

The choreographer application needs to know which cubes are connected, and which aren't. This is in order to spare the user the necessity of manually adding and removing cubes, as well as the possible errors that come with it ( mislabeled cubes, non-existant cubes, ... ). Cublis, however, have no need to know wether they are connected or not - the app either sends them commands and information, or it does not.

As a result, the connection protocol is not symmetrical. 

\begin{description}
\item[Standard protocol procedure]:

\begin{itemize}
\item[] \textbf{Cubli to PC:} "connect"
\item[] \textbf{PC to Cubli:} "connect"
\item[] \textbf{Cubli to PC:} "received"
\end{itemize}

at which point, the application changes the appropriate cubes status to "Unsynced"
\item[Alternate procedures]:

\begin{itemize}
\item If first message is not received
\end{itemize}
\end{description}
\subsubsection{When Syncing}
\subsubsection{When ...}

\section{Cubli Development}

In order to avoid introducing new bugs, care was taken to build on top of already-existing functionality rather than to modify it, as much as possible.

This means that except for a few additional line of codes, the controllers remain unchanged, and the code relevant to this project is composed of additional tasks for communication, choreography, and additions in mode management.\\

These relevant parts are what will be discussed here, rather than the entire cubli source code.

\subsection{Refresher: Cubli Source Code }

Before the project additions are described, it is useful to understand how the already-existing Cubli code handles inputs and events, as well as its general structure.\\

The main routines executed inside cubli softwares are managed by a realtime OS, which compartimentalizes them into various tasks, giving to each their respective processor access time, depending on their priority, period, and so on. This allows several processes to run in parallel, without necessarily affecting each other.\\

As an example, some tasks in the cubli source code are responsible for regularly checking that user inputs have been made, while others are responsible for the high-frequency control necessary during movements, such as the LQR controller task for balancing.\\

In addition, the OS also deals with interrupt routines and more specific functions outside of tasks, of which only the UART interrupt routine and button-press event handler are relevant to this report.\\

\subsubsection{From Button Press to Edge Balance}

\begin{itemize}
\item In \textbf{stm32f4xx\_it.c}, an interrupt is triggered when the mode button is pressed. Inside this interrupt, the \texttt{ \_modeNumber } variable is incremented once.

\item In \textbf{Controllers.c}, the ModeManagement task is repeated every few milliseconds. On every loop, it checks whether the mode number has changed - and whether the ReRunModeManagement variable has been set. If either of those conditions are true, it measures what position Cubli is currently in, and updates the controller task management variables accordingly - based on the current new mode number.\\

\textbf{Furthermore :} 
\begin{itemize}
\item[] Before updating those variables, it checks that the mode number was not changed two consecutive times in short order - indicating an involuntary double button press.
\item[] ReRunModeManagement is triggered inside ModeManagement, when cubli is set on its face. This is done order to re-update the controller task management variables - i.e. restart the current action. 
\item[] Following this, ModeManagement waits 5 seconds before updating the controller task management variables, in order to prevent immediate and ill-controlled behavior.
\end{itemize}

\item Still in \textbf{Controllers.c}, the task management variables, \texttt{\_jumpMode, \_balance, \_balancingMode} determine whether controller tasks execute actions or wait idly. These tasks access IMU and sensor measurements, calculate the necessary control actions, and set target actuation values appropriately. Actuation tasks then attempt to realize those values and interact with the servo hardware.
\end{itemize}

See Figure \ref{img:Controllers} for an visual overview of this process.

\begin{figure}[ht]
   \centering
   \includegraphics[width=0.75\textwidth]{img/Controllers.png}
   \caption{Block diagram of tasks in \texttt{Controllers.c}.}
   \label{img:Controllers}
\end{figure}


\subsection{Task Alterations}

The bulk of the additions to the Cubli code affected tasks, with the modification of several existing tasks, and creation of 2 new tasks for communication and choreography management.

This subsection describes the code modifications and additions to the relevant tasks performed in this project.

\subsubsection{ModeManagement Task}

Originally a task responsible for updating the global variables responsible for deciding which controllers get activated based on the current mode ( which is originally incremented through the press of a respective hardware button ), this functionality is conserved and extended in this project.\\

New modes are created for choreography, corresponding to the movement primitives, while the original modes are renamed to button modes, and relevant code sections are modified to make the new and original modes cohabitate. To this end, the original and old modes are distinguishable, allowing behavior which was only needed in old modes to be disabled for the new modes only.\\

[Old modes and New Modes]\\

[Pause upon resetting cubli on face?]\\

\subsubsection{ComManagement Task}

Created during this project, the ComManagement task contains both the code responsible for reading from the UART buffer, and a communication state machine similar to the one in the choreography app.\\

One notable difference between the communication behavior of cubli compared to the app is that its communication state machine is triggered regularly rather than on specific event occurences. This is discussed in further details inside this chapter's \textit{Communications} section, in the \textit{Information Reception \& Decryption} subsection.\\ 

As for the communication state machine, it implements the protocols which are described inside this chapter's \textit{Communications} section, in the \textit{Protocols} subsection. 

\subsubsection{ChoreographyManagement Task}

The choreography management task is only active during choreography, in which case it keeps track of the current primitive and run time, and adjusts the mode accordingly. It also implements behavior for pausing the choreography and notifying other cubes through the communication management when a move fails.

\subsubsection{TimelineStatus Task}

This code is responsible for storing the timeline information.\\

A cube stores only one timeline, its current timeline, which it does not modify. Alongside it, is a 'cache', a temporary timeline which is filled during sync, and then copied to the current timeline if the sync was successful, or discarded if unsuccessful.\\

[Limits of timeline storage, etc]

\subsubsection{Controller Tasks}

Some controller tasks were modified, to the smallest necessary extent, to fit with the choreographer functionality. Care was taken to ensure that the controller behavior would remain unchanged outside of choreography (i.e. with the relevant code sections being bypassed by if-clauses checking for choreography activity)

Three functionalities had to be added in the controllers' code:
\begin{itemize}
\item the ability for cubli to fall down to a face on its own
\item regulating the braking time to help synchronize choreographies
\item notifying the choreography management task when primitives are successful
\end{itemize}


\begin{figure}[ht]
   \centering
   \includegraphics[width=0.75\textwidth]{img/ChoreographerGUI.png}
   \caption{The CUBLI Choreographer Graphical User Interface.}
   \label{img:ControllersChoreography}
\end{figure}

\subsection{Other Alterations}

UART routine

Button-press event


    



